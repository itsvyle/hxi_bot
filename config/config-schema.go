// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package config

import "encoding/json"
import "fmt"
import "time"

type ConfigSchemaJson struct {
	// AiChatServices corresponds to the JSON schema field "aiChatServices".
	AiChatServices []ConfigSchemaJsonAiChatServicesElem `json:"aiChatServices" yaml:"aiChatServices" mapstructure:"aiChatServices"`

	// BotToken corresponds to the JSON schema field "botToken".
	BotToken string `json:"botToken" yaml:"botToken" mapstructure:"botToken"`

	// ChannelThreadsWatcherServices corresponds to the JSON schema field
	// "channelThreadsWatcherServices".
	ChannelThreadsWatcherServices []ConfigSchemaJsonChannelThreadsWatcherServicesElem `json:"channelThreadsWatcherServices" yaml:"channelThreadsWatcherServices" mapstructure:"channelThreadsWatcherServices"`

	// Enabled corresponds to the JSON schema field "enabled".
	Enabled bool `json:"enabled" yaml:"enabled" mapstructure:"enabled"`

	// GayGPTServices corresponds to the JSON schema field "gayGPTServices".
	GayGPTServices []ConfigSchemaJsonGayGPTServicesElem `json:"gayGPTServices,omitempty" yaml:"gayGPTServices,omitempty" mapstructure:"gayGPTServices,omitempty"`
}

type ConfigSchemaJsonAiChatServicesElem struct {
	// If true, the bot will have the command to start an autoconversation between
	// bots; only give it to a single bot per server or it'll break :)
	ActivateAutoConvos bool `json:"activateAutoConvos,omitempty" yaml:"activateAutoConvos,omitempty" mapstructure:"activateAutoConvos,omitempty"`

	// Delay in milliseconds between each message sent in autoconvos
	AutoConvosMessageDelay int `json:"autoConvosMessageDelay,omitempty" yaml:"autoConvosMessageDelay,omitempty" mapstructure:"autoConvosMessageDelay,omitempty"`

	// BotName corresponds to the JSON schema field "botName".
	BotName string `json:"botName" yaml:"botName" mapstructure:"botName"`

	// The guild id where the bot is running; useful for emojis only right now
	GuildId *string `json:"guildId,omitempty" yaml:"guildId,omitempty" mapstructure:"guildId,omitempty"`

	// List of user ids that can !kill the bot
	Killers []string `json:"killers,omitempty" yaml:"killers,omitempty" mapstructure:"killers,omitempty"`

	// MaxContextSize corresponds to the JSON schema field "maxContextSize".
	MaxContextSize int `json:"maxContextSize,omitempty" yaml:"maxContextSize,omitempty" mapstructure:"maxContextSize,omitempty"`

	// MaxTokens corresponds to the JSON schema field "maxTokens".
	MaxTokens int `json:"maxTokens,omitempty" yaml:"maxTokens,omitempty" mapstructure:"maxTokens,omitempty"`

	// OpenAIAPiKey corresponds to the JSON schema field "openAIAPiKey".
	OpenAIAPiKey string `json:"openAIAPiKey" yaml:"openAIAPiKey" mapstructure:"openAIAPiKey"`

	// OpenAIModelName corresponds to the JSON schema field "openAIModelName".
	OpenAIModelName string `json:"openAIModelName" yaml:"openAIModelName" mapstructure:"openAIModelName"`

	// Prompt corresponds to the JSON schema field "prompt".
	Prompt string `json:"prompt" yaml:"prompt" mapstructure:"prompt"`

	// Max requests per minute for the bot
	RpmLimit *int `json:"rpmLimit,omitempty" yaml:"rpmLimit,omitempty" mapstructure:"rpmLimit,omitempty"`

	// Temperature corresponds to the JSON schema field "temperature".
	Temperature float64 `json:"temperature,omitempty" yaml:"temperature,omitempty" mapstructure:"temperature,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConfigSchemaJsonAiChatServicesElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["botName"]; raw != nil && !ok {
		return fmt.Errorf("field botName in ConfigSchemaJsonAiChatServicesElem: required")
	}
	if _, ok := raw["openAIAPiKey"]; raw != nil && !ok {
		return fmt.Errorf("field openAIAPiKey in ConfigSchemaJsonAiChatServicesElem: required")
	}
	if _, ok := raw["openAIModelName"]; raw != nil && !ok {
		return fmt.Errorf("field openAIModelName in ConfigSchemaJsonAiChatServicesElem: required")
	}
	if _, ok := raw["prompt"]; raw != nil && !ok {
		return fmt.Errorf("field prompt in ConfigSchemaJsonAiChatServicesElem: required")
	}
	type Plain ConfigSchemaJsonAiChatServicesElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["activateAutoConvos"]; !ok || v == nil {
		plain.ActivateAutoConvos = false
	}
	if v, ok := raw["autoConvosMessageDelay"]; !ok || v == nil {
		plain.AutoConvosMessageDelay = 2500.0
	}
	if v, ok := raw["killers"]; !ok || v == nil {
		plain.Killers = []string{}
	}
	if v, ok := raw["maxContextSize"]; !ok || v == nil {
		plain.MaxContextSize = 5.0
	}
	if v, ok := raw["maxTokens"]; !ok || v == nil {
		plain.MaxTokens = 150.0
	}
	if v, ok := raw["temperature"]; !ok || v == nil {
		plain.Temperature = 0.8
	}
	*j = ConfigSchemaJsonAiChatServicesElem(plain)
	return nil
}

type ConfigSchemaJsonChannelThreadsWatcherServicesElem struct {
	// ChannelId corresponds to the JSON schema field "channelId".
	ChannelId string `json:"channelId" yaml:"channelId" mapstructure:"channelId"`

	// SendRenameButton corresponds to the JSON schema field "sendRenameButton".
	SendRenameButton bool `json:"sendRenameButton,omitempty" yaml:"sendRenameButton,omitempty" mapstructure:"sendRenameButton,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConfigSchemaJsonChannelThreadsWatcherServicesElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["channelId"]; raw != nil && !ok {
		return fmt.Errorf("field channelId in ConfigSchemaJsonChannelThreadsWatcherServicesElem: required")
	}
	type Plain ConfigSchemaJsonChannelThreadsWatcherServicesElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["sendRenameButton"]; !ok || v == nil {
		plain.SendRenameButton = true
	}
	*j = ConfigSchemaJsonChannelThreadsWatcherServicesElem(plain)
	return nil
}

type ConfigSchemaJsonGayGPTServicesElem struct {
	// BotToken corresponds to the JSON schema field "botToken".
	BotToken string `json:"botToken" yaml:"botToken" mapstructure:"botToken"`

	// The guild id where the bot is running; useful for bot roles
	GuildId *string `json:"guildId,omitempty" yaml:"guildId,omitempty" mapstructure:"guildId,omitempty"`

	// PossibleAnswers corresponds to the JSON schema field "possibleAnswers".
	PossibleAnswers []string `json:"possibleAnswers,omitempty" yaml:"possibleAnswers,omitempty" mapstructure:"possibleAnswers,omitempty"`

	// ReactTo corresponds to the JSON schema field "reactTo".
	ReactTo ConfigSchemaJsonGayGPTServicesElemReactTo `json:"reactTo,omitempty" yaml:"reactTo,omitempty" mapstructure:"reactTo,omitempty"`
}

type ConfigSchemaJsonGayGPTServicesElemReactTo map[string]struct {
	// TotalWeight corresponds to the JSON schema field "_totalWeight".
	TotalWeight int `json:"_totalWeight,omitempty" yaml:"_totalWeight,omitempty" mapstructure:"_totalWeight,omitempty"`

	// Weights corresponds to the JSON schema field "_weights".
	Weights []int `json:"_weights,omitempty" yaml:"_weights,omitempty" mapstructure:"_weights,omitempty"`

	// Emojis corresponds to the JSON schema field "emojis".
	Emojis []EmojisElem `json:"emojis" yaml:"emojis" mapstructure:"emojis"`

	// Weight of not reacting
	EmptyWeight int `json:"emptyWeight" yaml:"emptyWeight" mapstructure:"emptyWeight"`

	// ExcludeChannels corresponds to the JSON schema field "excludeChannels".
	ExcludeChannels []string `json:"excludeChannels" yaml:"excludeChannels" mapstructure:"excludeChannels"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConfigSchemaJsonGayGPTServicesElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["botToken"]; raw != nil && !ok {
		return fmt.Errorf("field botToken in ConfigSchemaJsonGayGPTServicesElem: required")
	}
	type Plain ConfigSchemaJsonGayGPTServicesElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["possibleAnswers"]; !ok || v == nil {
		plain.PossibleAnswers = []string{
			"gay",
		}
	}
	*j = ConfigSchemaJsonGayGPTServicesElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConfigSchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["aiChatServices"]; raw != nil && !ok {
		return fmt.Errorf("field aiChatServices in ConfigSchemaJson: required")
	}
	if _, ok := raw["botToken"]; raw != nil && !ok {
		return fmt.Errorf("field botToken in ConfigSchemaJson: required")
	}
	if _, ok := raw["channelThreadsWatcherServices"]; raw != nil && !ok {
		return fmt.Errorf("field channelThreadsWatcherServices in ConfigSchemaJson: required")
	}
	if _, ok := raw["enabled"]; raw != nil && !ok {
		return fmt.Errorf("field enabled in ConfigSchemaJson: required")
	}
	type Plain ConfigSchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.ChannelThreadsWatcherServices) > 1 {
		return fmt.Errorf("field %s length: must be <= %d", "channelThreadsWatcherServices", 1)
	}
	if len(plain.GayGPTServices) > 1 {
		return fmt.Errorf("field %s length: must be <= %d", "gayGPTServices", 1)
	}
	*j = ConfigSchemaJson(plain)
	return nil
}

type EmojisElem struct {
	// Cooldown in seconds for the emoji to be used to react again
	Cooldown int `json:"cooldown,omitempty" yaml:"cooldown,omitempty" mapstructure:"cooldown,omitempty"`

	// Emojis corresponds to the JSON schema field "emojis".
	Emojis []string `json:"emojis" yaml:"emojis" mapstructure:"emojis"`

	// DONT FILL. Timestamp of the last time the emoji was used
	LastUsed *time.Time `json:"lastUsed,omitempty" yaml:"lastUsed,omitempty" mapstructure:"lastUsed,omitempty"`

	// Weight corresponds to the JSON schema field "weight".
	Weight int `json:"weight" yaml:"weight" mapstructure:"weight"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EmojisElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["emojis"]; raw != nil && !ok {
		return fmt.Errorf("field emojis in EmojisElem: required")
	}
	type Plain EmojisElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["cooldown"]; !ok || v == nil {
		plain.Cooldown = 0.0
	}
	if v, ok := raw["weight"]; !ok || v == nil {
		plain.Weight = 1.0
	}
	*j = EmojisElem(plain)
	return nil
}
